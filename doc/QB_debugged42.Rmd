---
title: "STAT462 Assignment 3 â€“ Question 2"
author: "Xia Yu (62380486) & David Ewing (82171165)"
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M')`"
output:
  html_document 
---

```{r libraries}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
options(repos = c(CRAN = "https://cran.stat.auckland.ac.nz/"))
required_pkgs <- c(
  "dplyr", "tidyr", "readr", "tibble", "janitor", "skimr",
  "recipes", "rsample", "tidymodels", "rpart", "kernlab",
  "FactoMineR", "factoextra", "caret" , "purrr", "plotly",
  "RColorBrewer","glue","cluster","patchwork","ggplot2"
)




to_install <- setdiff(required_pkgs, rownames(installed.packages()))
if (length(to_install)) install.packages(to_install, dependencies = TRUE)
invisible(lapply(required_pkgs, library, character.only = TRUE))
```

## Data Load and Inspection

```{r data-load}
candidate <- c("../data/unzipped", "./data/unzipped", "data/unzipped")
data_dir  <- candidate[file.exists(candidate)][1]
if (is.na(data_dir)) stop("Cannot find data folder.")
path_annotated <- file.path(data_dir,"seeds_annotated.csv")
path_unlabeled <- file.path(data_dir,"seeds.csv")
annotated <- read_csv(path_annotated, locale=locale(decimal_mark=","), show_col_types=FALSE)
unlabeled <- read_csv(path_unlabeled, locale=locale(decimal_mark=","), show_col_types=FALSE)
has_annotated_index <- "...1" %in% names(annotated)  
has_unlabeled_index <- "...1" %in% names(unlabeled) 
if (has_annotated_index) annotated <- select(annotated,-...1)
if (has_unlabeled_index) unlabeled <- select(unlabeled,-...1)

glimpse(unlabeled)
glimpse(annotated)

```

```{r glimpses}
names(annotated) <- trimws(names(annotated))
annotated <- mutate(annotated, Class=as.factor(Class))
annotated |> glimpse()
head(annotated)
cat("NAs in annotated:", sum(is.na(annotated)), "\n")
names(unlabeled) <- trimws(names(unlabeled))
unlabeled |> glimpse()
head(unlabeled)
cat("NAs in unlabeled:", sum(is.na(unlabeled)), "\n")
```

## 3. Z-score Normalisation

```{r scale-unlabeled}
unlabeled_scaled <- select(unlabeled, where(is.numeric)) |>
  scale() |> as_tibble()
```

## 4. Kâ€‘means from Scratch


```{r kmeans-from-scratch}
# Compute squared distance from each row of X to a single centroid
delta_to_centroid <- function(X, centroid) {
  n <- nrow(X)
  p <- ncol(X)
  rowSums((X - matrix(centroid, n, p, byrow = TRUE))^2)  # ensure conformable dimensions
}

# Compute a distance matrix from all points to all centroids
delta_matrix <- function(X, centroids) {
  k <- nrow(centroids)
  sapply(seq_len(k), function(i) delta_to_centroid(X, centroids[i, ]))
}

# Compute total within-cluster sum of squares using f_kmeans output
compute_wss <- function(k, data, max_iter, start) {
  model <- f_kmeans(data, k, max_iter = max_iter, start = start)
  
  X <- as.matrix(data)                       # ensure matrix format
  clusters <- model$clusters                 # vector of cluster assignments
  centroids <- model$centroids               # matrix of final centroids
  
  total_withinss <- sum(sapply(seq_len(k), function(j) {
    idx <- which(clusters == j)              # indices assigned to cluster j
    if (length(idx) > 0) {
      point_set <- X[idx, , drop = FALSE]    # all points in cluster j
      centroid_row <- matrix(centroids[j, , drop = FALSE],
                             nrow = length(idx),
                             ncol = ncol(X),
                             byrow = TRUE)   # broadcast centroid for subtraction
      sum(rowSums((point_set - centroid_row)^2))  # WCSS for cluster j
    } else {
      0
    }
  }))
  
  return(total_withinss)
}

# Custom K-means implementation
f_kmeans <- function(data, k, max_iter = 100, start = 10) {
  set.seed(82171165)
  X <- as.matrix(data)                  # force to matrix
  n <- nrow(X)
  p <- ncol(X)

  centroids <- X[sample(n), , drop = FALSE][1:k, ]  # random initial centroids
  clusters <- integer(n)              # empty cluster assignment
  iter_reached <- NA

  for (iter in seq_len(max_iter)) {
    distances <- delta_matrix(X, centroids)              # distance matrix
    clusters_new <- max.col(-distances)                  # assign nearest centroid
    has_converged <- !anyNA(clusters_new) && all(clusters_new == clusters)

    if (has_converged) {
      iter_reached <- iter
      break
    }

    clusters <- clusters_new

    # Recompute centroids
    for (j in seq_len(k)) {
      idx <- which(clusters == j)
      if (length(idx) > 0) {
        centroids[j, ] <- colMeans(X[idx, , drop = FALSE])  # new centroid
      }
    }
  }

  # Recompute WCSS at the end with safe dimension handling
  total_withinss <- sum(sapply(seq_len(k), function(j) {
    idx <- which(clusters == j)
    if (length(idx) > 0) {
      point_set <- X[idx, , drop = FALSE]
      centroid_row <- matrix(centroids[j, , drop = FALSE],
                             nrow = length(idx),
                             ncol = ncol(X),
                             byrow = TRUE)
      sum(rowSums((point_set - centroid_row)^2))
    } else {
      0
    }
  }))

  # Return result object
  list(
    clusters = clusters,
    centroids = centroids,
    iter = iter_reached,
    total_withinss = total_withinss
  )
}


```


 









```{r test-toggle}
testing <- FALSE
if (testing) {
  message("ðŸŸ¡ Quick test: 500 rows, k=2:4, iter.max=5")
  unlabeled_use <- unlabeled_scaled[1:500,]; k_vals <- 2:4; max_iter <- 5
} else {
  message("ðŸŸ¢ Full run: all rows, k=2:10, iter.max=100")
  unlabeled_use <- unlabeled_scaled; k_vals <- 2:10; max_iter <- 100
}
k_vals <- 2:10
unlabeled_use <- unlabeled_scaled
wss_values <- vapply(k_vals, function(k) compute_wss(k, unlabeled_use, max_iter, start), numeric(1))

unlabeled_use <- unlabeled_scaled

```

```{r diagnostics}
debug_tbl <- purrr::map_dfr(k_vals, function(k) {
  res <- f_kmeans(unlabeled_scaled,k,max_iter)
  tot_within <- compute_wss(k,unlabeled_use,max_iter)
  grand_mean <- colMeans(unlabeled_use)
  totss <- sum(rowSums((as.matrix(unlabeled_use) -
           matrix(grand_mean,nrow(unlabeled_use),ncol(unlabeled_use),byrow=TRUE))^2))
  betweenss <- totss - tot_within
  tibble(k, tot_within, totss, betweenss,
         identity_ok=abs(totss-(betweenss+tot_within))<1e-8)
})
print(debug_tbl)
```







```{r elbow-and-silhouette, fig.cap="Elbow and Silhouette plots for determining optimal k"}
# Setup: input data and cluster range
unlabeled_use <- unlabeled_scaled
k_vals <- 2:10
max_iter <- 100
start <- 10

# Elbow: total within-cluster sum of squares
wss_values <- vapply(
  k_vals,
  function(k) compute_wss(k, unlabeled_use, max_iter, start),
  numeric(1)
)

# Silhouette: average silhouette width for each k
diss_matrix <- dist(unlabeled_use)
silhouette_values <- vapply(k_vals, function(k) {
  model <- f_kmeans(unlabeled_use, k, max_iter = max_iter, start = start)
  if (!is.null(model$clusters)) {
    sil <- silhouette(model$clusters, diss_matrix)
    mean(sil[, 3])
  } else {
    NA_real_
  }
}, numeric(1))

# Plot Elbow
plot_wss <- qplot(k_vals, wss_values, geom = c("point", "line"),
                  xlab = "Number of Clusters", ylab = "Total WCSS") +
  ggtitle("Elbow Method") + theme_minimal()

# Plot Silhouette
plot_sil <- qplot(k_vals, silhouette_values, geom = c("point", "line"),
                  xlab = "Number of Clusters", ylab = "Average Silhouette Width") +
  ggtitle("Silhouette Method") + theme_minimal()

# Render both plots
plot_sil
plot_wss
```


```{r elbow-plot-original,eval=FALSE}
unlabeled_use <- unlabeled_scaled
k_vals <- 2:10
max_iter <- 100
start <- 10
wss_values <- vapply(
  k_vals,
  function(k) compute_wss(k, unlabeled_use, max_iter, start),
  numeric(1)
)

if (all(is.na(wss_values)) || all(!is.finite(wss_values))) {
  warning("All clustering attempts failed. No elbow plot can be drawn.")
} else {
if (all(is.na(wss_values)) || all(!is.finite(wss_values))) {
  warning("All clustering attempts failed. No elbow plot can be drawn.")
} else {
if (exists("wss_values") && any(is.finite(wss_values))) {
plot(
  k_vals, wss_values, type="b", pch=19,
  xlab = "k",
  ylab = expression(paste("Within-cluster ", sum((x[i] - c[k])^2))),
  main = if (testing) "Elbow (testing)" else "Elbow (full)",
  xaxt = "n"
)
axis(1, at = k_vals)
}
}
}



## 5. Final Clustering

```{r cluster-final, echo=TRUE}
# Final clustering with user-selected k
k_best <- 7
res_final <- f_kmeans(
  unlabeled_scaled,
  k_best,
  max_iter,
  start
)

# Attach cluster assignment to unlabeled_use
unlabeled_use$cluster <- res_final$clusters

# Optional: also compute a label mapping using majority vote (saved separately)
if (exists("annotated")) {
  label_col <- "Class"
  annotated_subset <- annotated |> filter(!is.na(.data[[label_col]]))

  # Assign clusters to annotated points (assumes same row indexing)
  annotated_subset$cluster <- res_final$clusters[as.integer(rownames(annotated_subset))]

  # Determine the most common class in each cluster
  mapping <- annotated_subset |>
    count(.data[[label_col]], cluster, name = "n") |>
    group_by(cluster) |>
    slice_max(n, n = 1, with_ties = FALSE) |>
    ungroup()

  cluster_map_vote <- setNames(as.character(mapping[[label_col]]), mapping$cluster)

  # Assign vote-based labels separately
  unlabeled_use$label_vote <- cluster_map_vote[as.character(unlabeled_use$cluster)]
}

# Print diagnostic output
res_final$iter
table(unlabeled_use$cluster)

```




```{r assign-class-labels-proximity, echo=TRUE, message=FALSE}
# Use centroids of clusters and annotated class groups to align labels by proximity

# Get centroids of clusters (in scaled unlabeled data)
cluster_centroids <- unlabeled_scaled %>%
  as.data.frame() %>%
  mutate(cluster = res_final$clusters) %>%
  group_by(cluster) %>%
  summarise(across(everything(), mean), .groups = "drop")

# Get centroids of known classes (in scaled annotated data)
annotated_scaled <- annotated %>%
  mutate(Class = as.factor(Class)) %>%
  select(-Class) %>%
  scale() %>%
  as.data.frame()
annotated_centroids <- annotated_scaled %>%
  mutate(Class = annotated$Class) %>%
  group_by(Class) %>%
  summarise(across(everything(), mean), .groups = "drop")

# Compute distances between each cluster centroid and class centroid
cluster_matrix <- as.matrix(select(cluster_centroids, -cluster))
class_matrix <- as.matrix(select(annotated_centroids, -Class))
distance_matrix <- as.matrix(dist(rbind(cluster_matrix, class_matrix)))

# Extract top-left block: distances between clusters and classes
k <- nrow(cluster_matrix)
m <- nrow(class_matrix)
prox_matrix <- distance_matrix[1:k, (k + 1):(k + m)]

# Assign each cluster to closest class
closest_class_index <- apply(prox_matrix, 1, which.min)
closest_class_labels <- annotated_centroids$Class[closest_class_index]

# Map cluster numbers to class labels
cluster_to_label <- setNames(as.character(closest_class_labels), cluster_centroids$cluster)
unlabeled_use$label <- cluster_to_label[as.character(unlabeled_use$cluster)]
```



```{r pca-plot-with-class-labels, eval=F, echo=TRUE, message=FALSE, warning=FALSE}
pca_result <- PCA(unlabeled_scaled, graph = FALSE)
pca_coords <- as.data.frame(pca_result$ind$coord[, 1:3])
colnames(pca_coords) <- c("PC1", "PC2", "PC3")

# Use class labels instead of cluster numbers
pca_coords$Class <- unlabeled_use$label

# Color palette
pal <- brewer.pal(max(3, length(unique(pca_coords$Class))), "Set2")

# Plot
plot_ly(data = pca_coords,
        x = ~PC1, y = ~PC2, z = ~PC3,
        color = ~Class, colors = pal,
        type = "scatter3d", mode = "markers",
        marker = list(size = 3)) |>
  layout(title = "PCA â€“ Colored by Assigned Class Labels",
         legend = list(title = list(text = "Class")),
         scene = list(
           xaxis = list(title = "PC1"),
           yaxis = list(title = "PC2"),
           zaxis = list(title = "PC3")
         ))

```


```{r hcpc-3d-1, message=FALSE, warning=FALSE, eval=TRUE}
# Compute PCA and HCPC if not already done
if (!exists("res.pca") || !exists("res.hcpc")) {
  hcpc_data <- scale(unlabeled)
  res.pca <- PCA(hcpc_data, graph = FALSE)
  res.hcpc <- HCPC(res.pca, graph = FALSE)
}

# Extract first 3 principal components
pca_coords <- as.data.frame(res.pca$ind$coord[, 1:3])
colnames(pca_coords) <- c("PC1", "PC2", "PC3")

# Attach cluster labels from unlabeled_use
pca_coords$cluster <- factor(unlabeled_use$cluster)

# Optional: also attach letter labels if needed
pca_coords$Class <- LETTERS[as.integer(pca_coords$cluster)]

# Color palette based on number of clusters
pal <- brewer.pal(max(3, length(levels(pca_coords$cluster))), "Set2")

# Plot differently depending on output format
if (knitr::is_html_output()) {
  plot_ly(data = pca_coords,
          x = ~PC1, y = ~PC2, z = ~PC3,
          type = "scatter3d", mode = "markers",
          color = ~Class, colors = pal,
          marker = list(size = 4)) |>
    layout(
      scene = list(
        xaxis = list(title = "PC1"),
        yaxis = list(title = "PC2"),
        zaxis = list(title = "PC3")
      ),
      legend = list(title = list(text = "Class"))
    )
} else {
  fviz_cluster(res.hcpc,
               geom = "point",
               repel = TRUE,
               show.clust.cent = TRUE,
               axes = c(1, 2),
               palette = pal)
}



```{r hcpc-3d-1-orignial,eval=F, message=FALSE, warning=FALSE, eval=T}
if (!exists("res.pca")||!exists("res.hcpc")) {
  hcpc_data<-scale(unlabeled)
  res.pca<-PCA(hcpc_data,graph=FALSE)
  res.hcpc<-HCPC(res.pca,graph=FALSE)
}
pca_coords<-as.data.frame(res.pca$ind$coord[,1:3]);
colnames(pca_coords)<-c("PC1","PC2","PC3");
pca_coords$cluster <- factor(unlabeled_use$cluster)
pal<-brewer.pal(max(3,length(levels(pca_coords$cluster))),"Set2")
if (knitr::is_html_output()) {
  plot_ly(data=pca_coords,x=~PC1,y=~PC2,z=~PC3,type="scatter3d",mode="markers",
          color=~cluster,colors=pal,marker=list(size=4))|>
    layout(scene=list(xaxis=list(title="PC1"),yaxis=list(title="PC2"),zaxis=list(title="PC3")),
           legend=list(title=list(text="Cluster")))
} else {
  fviz_cluster(res.hcpc,geom="point",repel=TRUE,show.clust.cent=TRUE,axes=c(1,2),palette=pal)
}
```


```{r pca-plot-by-centroid-labels,eval=F,  message=FALSE, warning=FALSE}
pca_coords2 <- as.data.frame(pca_result$ind$coord[, 1:3])
colnames(pca_coords2) <- c("PC1", "PC2", "PC3")
pca_coords2$label <- unlabeled_use$label_proximity

pal2 <- brewer.pal(max(3, length(unique(pca_coords2$label))), "Set2")

plot_ly(data = pca_coords2, 
        x = ~PC1, y = ~PC2, z = ~PC3,
        color = ~label, colors = pal2,
        type = "scatter3d", mode = "markers",
        marker = list(size = 3)) |>
  layout(title = "PCA - Colored by Class Label (Centroid Proximity)",
         legend = list(title = list(text = "Class")),
         scene = list(
           xaxis = list(title = "PC1"),
           yaxis = list(title = "PC2"),
           zaxis = list(title = "PC3")
         ))
```





## 6. Classification of Annotated Data

```{r annotated-classification, echo=TRUE}
# Ensure Class is a factor
annotated$Class <- as.factor(annotated$Class)

# Remove class temporarily, scale, then add back
ann <- select(annotated, -Class) |> scale() |> as_tibble()
ann$Class <- annotated$Class

# Create training/test split
set.seed(82171165)
idx <- createDataPartition(ann$Class, p = 0.7, list = FALSE)
train <- ann[idx, ]
test  <- ann[-idx, ]

# Train classifier
model <- train(Class ~ ., data = train, method = "svmRadial")

# Predict and evaluate
pred <- predict(model, test)
confusionMatrix(pred, test$Class)
```

```{r pca-plot-final-labels, echo=TRUE, message=FALSE, warning=FALSE}
# Run PCA on scaled data
pca_result <- PCA(unlabeled_scaled, graph = FALSE)
pca_coords <- as.data.frame(pca_result$ind$coord[, 1:3])
colnames(pca_coords) <- c("PC1", "PC2", "PC3")

# Use Class labels derived from cluster mapping
pca_coords$Class <- unlabeled_use$label

# Color palette based on unique Class values
pal <- brewer.pal(max(3, length(unique(pca_coords$Class))), "Set2")

# 3D PCA plot using plotly
plot_ly(data = pca_coords,
        x = ~PC1, y = ~PC2, z = ~PC3,
        color = ~Class, colors = pal,
        type = "scatter3d", mode = "markers",
        marker = list(size = 3)) |>
  layout(title = "PCA - Colored by Assigned Class Labels",
         legend = list(title = list(text = "Class")),
         scene = list(
           xaxis = list(title = "PC1"),
           yaxis = list(title = "PC2"),
           zaxis = list(title = "PC3")
         ))
```

 
```{r pca-plot-final-labels-original,eval=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
pca_result <- PCA(unlabeled_scaled, graph = FALSE)
pca_coords <- as.data.frame(pca_result$ind$coord[, 1:3])
colnames(pca_coords) <- c("PC1", "PC2", "PC3")

# Use Class labels derived from cluster mapping
pca_coords$Class <- unlabeled_use$label

# Color palette
pal <- brewer.pal(max(3, length(unique(pca_coords$Class))), "Set2")

# Plot
plot_ly(data = pca_coords,
        x = ~PC1, y = ~PC2, z = ~PC3,
        color = ~Class, colors = pal,
        type = "scatter3d", mode = "markers",
        marker = list(size = 3)) |>
  layout(title = "PCA â€“ Colored by Assigned Class Labels",
         legend = list(title = list(text = "Class")),
         scene = list(
           xaxis = list(title = "PC1"),
           yaxis = list(title = "PC2"),
           zaxis = list(title = "PC3")
         ))

```

## 7. HCPC 3D Factor Map

```{r hcpc-3d, message=FALSE, warning=FALSE, eval=F}
if (!exists("res.pca")||!exists("res.hcpc")) {
  hcpc_data<-scale(unlabeled)
  res.pca<-PCA(hcpc_data,graph=FALSE)
  res.hcpc<-HCPC(res.pca,graph=FALSE)
}
pca_coords<-as.data.frame(res.pca$ind$coord[,1:3]);
colnames(pca_coords)<-c("PC1","PC2","PC3");
pca_coords$cluster <- factor(unlabeled_use$cluster)
pal<-brewer.pal(max(3,length(levels(pca_coords$cluster))),"Set2")
if (knitr::is_html_output()) {
  plot_ly(data=pca_coords,x=~PC1,y=~PC2,z=~PC3,type="scatter3d",mode="markers",
          color=~cluster,colors=pal,marker=list(size=4))|>
    layout(scene=list(xaxis=list(title="PC1"),yaxis=list(title="PC2"),zaxis=list(title="PC3")),
           legend=list(title=list(text="Cluster")))
} else {
  fviz_cluster(res.hcpc,geom="point",repel=TRUE,show.clust.cent=TRUE,axes=c(1,2),palette=pal)
}
```

```{r}

 

# Combine cluster info with PCA coordinates
pca_clustered <- pca_coords |>
  mutate(cluster = unlabeled_use$cluster)

# Select one cluster to highlight
target_cluster <- 3
highlight <- filter(pca_clustered, cluster == target_cluster)

# Plot just the selected cluster in 2D
ggplot(highlight, aes(x = PC1, y = PC2)) +
  geom_point(color = "steelblue", alpha = 0.7) +
  labs(
    title = glue("Cluster {target_cluster}: PCA Projection"),
    x = "PC1", y = "PC2"
  ) +
  theme_minimal()



```


```{r plot-single-cluster}
# Set which cluster to highlight
target_cluster <- 3

# Compute PCA coordinates if not already done
if (!exists("pca_coords")) {
  pca_coords <- as.data.frame(res.pca$ind$coord[, 1:2])
  colnames(pca_coords) <- c("PC1", "PC2")
}

# Add cluster assignment
pca_coords$cluster <- factor(res_final$clusters)

# Filter only points from the target cluster
highlight <- pca_coords |> filter(cluster == target_cluster)

# Plot only this cluster
ggplot(highlight, aes(x = PC1, y = PC2)) +
  geom_point(color = "steelblue", size = 3, alpha = 0.6) +
  labs(
    title = glue("Points from Cluster {target_cluster}"),
    x = "PC1", y = "PC2"
  ) +
  theme_minimal()



```
